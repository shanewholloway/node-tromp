// Generated by CoffeeScript 1.4.0
var WalkEntry, WalkFuncComp, WalkNode, WalkRoot, createTaskQueue, events, fs, path, tromp,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

fs = require('fs');

path = require('path');

events = require('events');

WalkFuncComp = (function(_super) {

  __extends(WalkFuncComp, _super);

  function WalkFuncComp() {
    WalkFuncComp.__super__.constructor.apply(this, arguments);
  }

  WalkFuncComp.prototype.any = function() {
    return this.anyEx(arguments);
  };

  WalkFuncComp.prototype.anyEx = function(optList) {
    var fnList, opt, _i, _len,
      _this = this;
    fnList = [];
    for (_i = 0, _len = optList.length; _i < _len; _i++) {
      opt = optList[_i];
      this.addFilterFn(opt);
    }
    return function(e) {
      return _this.some(function(fn) {
        return fn.call(this, e);
      });
    };
  };

  WalkFuncComp.prototype.all = function() {
    return this.allEx(arguments);
  };

  WalkFuncComp.prototype.allEx = function(optList) {
    var opt, _i, _len,
      _this = this;
    for (_i = 0, _len = optList.length; _i < _len; _i++) {
      opt = optList[_i];
      this.addFilterFn(opt);
    }
    return function(e) {
      return _this.every(function(fn) {
        return fn.call(this, e);
      });
    };
  };

  WalkFuncComp.prototype.addFilterFn = function(opt) {
    if (opt.call != null) {
      return this.push(opt);
    }
    if (opt.match != null) {
      this.push(function(e) {
        return e.match(opt.match);
      });
    }
    if (opt.accept != null) {
      this.push(function(e) {
        return e.accept(opt.accept);
      });
    }
    if (opt.reject != null) {
      this.push(function(e) {
        return !e.reject(opt.reject);
      });
    }
    if (!opt.allFiles) {
      this.push(function(e) {
        return !e.excluded;
      });
    }
    if (opt.isFile) {
      this.push(function(e) {
        return e.isFile();
      });
    }
    if (opt.isDirectory) {
      return this.push(function(e) {
        return e.isDirectory();
      });
    }
  };

  return WalkFuncComp;

})(Array);

WalkEntry = (function() {

  Object.defineProperties(WalkEntry.prototype, {
    node: {
      writable: true,
      enumerable: false
    },
    root: {
      get: function() {
        return this.node.root;
      },
      enumerable: false
    }
  });

  function WalkEntry(node) {
    this.node = node;
    this;

  }

  WalkEntry.prototype.init = function(name) {
    this.name = name;
    return this;
  };

  WalkEntry.prototype.stat = function(cb) {
    var res,
      _this = this;
    if (res = this._stat != null) {
      if (typeof cb === "function") {
        cb(this, stat);
      }
    } else {
      this.root.fs_stat(this.path(), function(err, stat) {
        Object.defineProperty(_this, '_stat', {
          value: stat,
          enumerable: false
        });
        if (err) {
          console.error('statError:', err, stat);
        }
        return typeof cb === "function" ? cb(_this, stat) : void 0;
      });
    }
    return this;
  };

  WalkEntry.prototype.path = function() {
    return path.resolve(this.node._path, this.name);
  };

  WalkEntry.prototype.isFile = function() {
    var _ref;
    return (_ref = this._stat) != null ? _ref.isFile() : void 0;
  };

  WalkEntry.prototype.isDirectory = function() {
    var _ref;
    return (_ref = this._stat) != null ? _ref.isDirectory() : void 0;
  };

  WalkEntry.prototype.match = function(rx, ctx) {
    if (!(rx != null)) {
      return null;
    }
    if (rx.call != null) {
      return rx.call(ctx, this);
    }
    return this.name.match(rx) != null;
  };

  WalkEntry.prototype.exclude = function(v) {
    if (v === void 0 || !!v) {
      return this.excluded = true;
    } else {
      delete this.excluded;
      return false;
    }
  };

  WalkEntry.prototype.filter = function(rx, ctx) {
    return (rx != null) && this.exclude(this.match(rx, ctx)) || false;
  };

  WalkEntry.prototype.accept = function(rx, ctx) {
    if (!(rx != null) || this.match(rx, ctx)) {
      this.exclude(false);
      return true;
    } else {
      return false;
    }
  };

  WalkEntry.prototype.reject = function(rx, ctx) {
    if (!(rx != null) || this.match(rx, ctx)) {
      this.exclude(true);
      return true;
    } else {
      return false;
    }
  };

  WalkEntry.prototype.walk = function() {
    if (this.excluded || !this.isDirectory()) {
      this.root.walk(this.path());
      return true;
    } else {
      return false;
    }
  };

  WalkEntry.prototype.autoWalk = function() {
    if (!this.excluded && this.isDirectory()) {
      this.root.autoWalk(this.path());
      return true;
    } else {
      return false;
    }
  };

  return WalkEntry;

})();

WalkNode = (function() {

  Object.defineProperties(WalkNode.prototype, {
    root: {
      writable: true,
      enumerable: false
    },
    WalkFuncComp: {
      value: WalkFuncComp
    }
  });

  function WalkNode(root) {
    this.root = root;
  }

  WalkNode.prototype.list = function(_path, ee, done) {
    var nodeEntry, self;
    this._path = _path;
    self = this;
    nodeEntry = new this.root.WalkEntry(this);
    this.root.fs_readdir(this._path, function(err, entries) {
      var n;
      entries = (entries || []).map(function(e) {
        return Object.create(nodeEntry).init(e);
      });
      self._entries = entries;
      ee.emit('listing', self);
      n = entries.length;
      return entries.forEach(function(entry) {
        return entry.stat(function(entry, stat) {
          if (stat != null) {
            ee.emit('entry', entry, self);
            if (stat.isFile()) {
              ee.emit('file', entry, self);
            }
            if (stat.isDirectory()) {
              ee.emit('dir', entry, self);
              entry.autoWalk();
            }
          }
          if (--n === 0) {
            ee.emit('listed', self);
            return typeof done === "function" ? done(self) : void 0;
          }
        });
      });
    });
    return self;
  };

  WalkNode.prototype.path = function() {
    return this._path;
  };

  WalkNode.prototype.base = function() {
    return path.relative(this.root._path, this._path);
  };

  WalkNode.prototype.entries = function() {
    var e, fn, res;
    res = this._entries;
    if (!(res != null)) {
      return [];
    }
    if (!arguments.length) {
      return res;
    }
    fn = new this.WalkFuncComp().allEx(arguments);
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = res.length; _i < _len; _i++) {
        e = res[_i];
        if (fn(e)) {
          _results.push(e);
        }
      }
      return _results;
    })();
  };

  WalkNode.prototype.filter = function(rx, ctx) {
    return this.entries(function(e) {
      return e.filter(rx, ctx);
    });
  };

  WalkNode.prototype.accept = function(rx, ctx) {
    return this.entries(function(e) {
      return e.accept(rx, ctx);
    });
  };

  WalkNode.prototype.reject = function(rx, ctx) {
    return this.entries(function(e) {
      return e.reject(rx, ctx);
    });
  };

  WalkNode.prototype.matching = function() {
    var opts, rx;
    rx = arguments[0], opts = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (rx != null) {
      opts.unshift({
        match: rx
      });
    }
    return this.entries.apply(this, opts);
  };

  WalkNode.prototype.files = function() {
    var opts;
    opts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    opts.unshift({
      isFile: true
    });
    return this.entries.apply(this, opts);
  };

  WalkNode.prototype.dirs = function() {
    var opts;
    opts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    opts.unshift({
      isDirectory: true
    });
    return this.entries.apply(this, opts);
  };

  WalkNode.prototype.walk = function() {
    var d, opts, _i, _len, _ref;
    opts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    opts.unshift({
      isDirectory: true
    });
    _ref = this.entries.apply(this, opts);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      d = _ref[_i];
      d.walk();
    }
    return this;
  };

  return WalkNode;

})();

createTaskQueue = function(nTasks, schedule) {
  var fnq, n, queueTask, step, _active;
  if (schedule == null) {
    schedule = process.nextTick;
  }
  n = 0;
  fnq = [];
  _active = false;
  step = function(c) {
    if (c != null) {
      n -= c;
      if (!_active) {
        _active = true;
        schedule(step);
      }
    } else {
      _active = false;
      while (fnq.length && n <= nTasks) {
        try {
          n++;
          fnq.shift()();
        } catch (err) {
          n--;
        }
      }
      if (typeof queueTask.report === "function") {
        queueTask.report(nTasks, n, fnq.length);
      }
    }
    return nTasks - n - fnq.length;
  };
  queueTask = function(inner, outer) {
    fnq.push(outer.bind(this, function() {
      step(1);
      return inner.apply(this, arguments);
    }));
    return step(0);
  };
  queueTask.clear = function() {
    fnq.length = 0;
    return step(0);
  };
  queueTask.throttle = function(n) {
    nTasks = n;
    return step(0);
  };
  return queueTask;
};

WalkRoot = (function(_super) {

  __extends(WalkRoot, _super);

  function WalkRoot() {
    return WalkRoot.__super__.constructor.apply(this, arguments);
  }

  WalkRoot.prototype.WalkEntry = WalkEntry;

  WalkRoot.prototype.WalkNode = WalkNode;

  WalkRoot.prototype.init = function(_path, opt, schedule) {
    var _this = this;
    this._path = _path;
    if (schedule == null) {
      schedule = process.nextTick;
    }
    events.EventEmitter.call(this);
    this.opt = opt || {};
    this.queueTask = createTaskQueue(this.opt.tasks || 10, schedule);
    if (!this.opt.showHidden) {
      this.reject(/^\./);
    }
    schedule(function() {
      return _this.walk(_this._path);
    });
    return this;
  };

  WalkRoot.prototype._activeWalks = 0;

  WalkRoot.prototype.walk = function(aPath) {
    var _this = this;
    aPath = path.resolve(aPath);
    if (this._activeWalks++ === 0) {
      this.emit('active', true);
    }
    return new this.WalkNode(this).list(aPath, this, function() {
      if (--_this._activeWalks === 0) {
        return _this.emit('active', false);
      }
    });
  };

  WalkRoot.prototype.autoWalk = function(aPath) {
    return this.walk(aPath);
  };

  WalkRoot.prototype.filter = function(rx, ctx) {
    if (rx != null) {
      this.on('entry', function(e) {
        return e.filter(rx, ctx);
      });
    }
    return this;
  };

  WalkRoot.prototype.accept = function(rx, ctx) {
    if (rx != null) {
      this.on('entry', function(e) {
        return e.accept(rx, ctx);
      });
    }
    return this;
  };

  WalkRoot.prototype.reject = function(rx, ctx) {
    if (rx != null) {
      this.on('entry', function(e) {
        return e.reject(rx, ctx);
      });
    }
    return this;
  };

  WalkRoot.prototype.fs_stat = function(aPath, cb) {
    return this.queueTask(cb, function(cb) {
      return fs.stat(aPath, cb);
    });
  };

  WalkRoot.prototype.fs_readdir = function(aPath, cb) {
    return this.queueTask(cb, function(cb) {
      return fs.readdir(aPath, cb);
    });
  };

  return WalkRoot;

})(events.EventEmitter);

tromp = function() {
  var args, _ref;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return (_ref = new tromp.WalkRoot()).init.apply(_ref, args);
};

tromp.WalkFuncComp = WalkFuncComp;

tromp.WalkRoot = WalkRoot;

tromp.WalkEntry = WalkEntry;

tromp.WalkNode = WalkNode;

module.exports = tromp.tromp = tromp;
